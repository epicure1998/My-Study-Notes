布隆过滤器是计算机科学中一个让我困扰了很久的问题
下面我将用几分钟时间，把它的原理解释给你们
我将会侧重讲解布隆过滤器为什么会存在
而不是仅仅告诉你们它是什么
我会结合实际的应用场景进行讲解
如果你喜欢的话，就继续看下去吧！
现在有这样一个问题呈现在我们面前
我们都知道如何解决这样一个问题
但是我们也可以通过过滤器让这个问题更好的得到解决
我会用这个nodejs作为服务器，来接受http请求
然后从存储层中检查所请求的用户名是否存在
这样的一个功能是很容易被实现的，不是吗？
在数据库中存放有所有用户的username
然后用户在客户端通过正确的请求
例如请求查看paul这样一个用户是否存在
服务器接受你的请求后，通过SQL在数据库中查找
然后根据查询的结果，返回用户名或返回用户不存在
但是问题是，这样的响应流程特别的慢！
服务器也会变得压力山大
多个用户在同一时间请求服务，问哪哪个用户是否存在
这样服务器的响应就会变慢
那么我们如何才能解决这样的问题呢？
我们可以用Redis呀
预先从数据库中将数据取出存入Redis的内存缓存中
没错，运用Redis是绝对能解决这样的问题的
当你再次用刚刚相同的方式访问数据库时
服务器就会先从Redis的缓存中查找你想要的数据
如果在缓存中找不到，就会去访问存储层的数据库
这样做的可能会影响响应的效率
而且将数据做为缓存意味着你将消耗两倍的存储空间
仅仅是为了解决这样一个简单的问题，你就要做这么多
所以我们都知道该如何解决这个问题
但是一些计算机科学家想到了更加高效的解决方案
这就是布隆过滤器
让我来给你们解释一下布隆过滤器是什么
通过布隆过滤器我们能够在使用非常少的内存空间
解决刚刚谈到的相同的问题
我会用一个64位的存储空间来讨论这个问题
这个64位的空间上有许多的01数据
这里的空就代表着0
这里是1，这里是很多的0，然后又出现一个1
下面我们来讨论一下
当我们再次发起请求，服务器会先做这样的工作
服务器会先将你请求的username进行一次hash
然后将它与64进行取模
取模意义是将HASH值除以64所得到的余数
取余后的范围只会在0～63之间
这样取余后的结果就都会映射到这64个格子上的其中一个
在这个例子里，paul在hash并取余后得到了3
我们在这个64位的空间中索引为3的格子上的数进行检查
如果是0的就代表不存在
那么你就可以确定用户请求的username不在数据库
paul不存在，服务器就压根不需要访问数据库
让我们看下一个例子
我们要请求Jack是否存在
服务器在接受请求后，先对"jack"进行hash
得到的Hash值再次与64进行取余
这样就又会得到一个0～63之间的数字
我们得到63，拿着它到那个64位的空间里去查
发现对应的格子是1，如果是1
这就意味着，jack这样的用户可能存在
可能存在意味着，也许有其他的用户名进行Hash并取余后
得到的结果也是63，所以jack这样的一个值不是唯一的
这其实已经够了，如果是1，我们就可以去数据库查查看
这样我们就能过滤到一大部分不存在的用户名
这样的解决方案是完美的吗？不是的
但是它是高效的
因为它能过滤掉很多不必要的存储层访问
Cassandra就是用这种方式对请求进行过滤的
如果你想要避免本不需要访问存储层的请求
或是你并不确实你想要访问的结果是否存在
布隆过滤器就是一个很好的选择
让我们看看怎样去构建一个布隆过滤器
下面我有一个所有值都为0的64位的存储空间
我们先建立jack的数据
将jack数据Hash后按64取余，然后在相应位置设1
这就是布隆过滤器构建的过程
下面我们用同样的访问构建paul，先Hash再取余
我们得到了3，那么在索引为3的位置设1
下面是Tim，相同的方法Hash后取余
你看我们又很巧的得到了63，如果63索引已经为1
那我们就不需要做什么
这样的结果是正确的，因为我们只有64个格子
下面轮到Ali，先Hash然后取余，得到了结果4
那么就在索引为4的地方设1
这就是布鲁过滤器基本的原理
这些仅仅只是布隆过滤器的基础
我知道真正布隆过滤器的运用会更加复杂
会使用到3个更大位数的存储空间，进行3次Hash再取余
从而减少数据的重复
但我所讲的就是布隆过滤器最底层的原理
这也是它为什么存在的原因
但它也有局限性
当所有的位都是1的情况下
你的布隆过滤器就会失去作用
你每次的请求还是会去访问数据库
过滤器的失效并不会给服务器带来多大的负担
但同样也不再为你的数据库过滤没必要访问
你将布隆过滤器设置得更大，就会消耗更多的空间
但如果你将过滤器设置的小了
就会容易使过滤器失去作用，会增大访问数据库的概率
谢谢观看









