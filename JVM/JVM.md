[TOC]

# JVM

1. 位置
2. 体系结构
3. 类加载器
4. 双亲委派机制
5. 沙箱安全机制
6. Native
7. PC寄存器
8. 方法去
9. 栈
10. 三种JVM
11. 堆
12. 新生区，老年区
13. 永久区
14. 堆内存调优
15. GC
16. JMM
17. 总结

## 垃圾收集器与内存分配

### 对象是否死亡的判断：

* 引用计数算法：
* 可达性分析算法：

### 再谈引用：

四种引用的类型：

* 强引用：永远不清除
* 软引用：没有直接引用切内存空间不足时，进行GC
* 弱引用：只要没有引用了就GC
* 虚引用：唯一作用是能让一个对象被收集器回收时得到一个系统通知

### 垃圾处理算法：方法论

Eden 和 Survivor 区域的比例是：8比1

* 标记-清除算法：易造成碎片化，容易导致以后需要分配大对象时，无法分配内存从而提前触发垃圾处理算法
* 复制算法：将存活的对象复制后重新整理，存活率高的情况下效率会很低
* 标记-整理算法：
* 分代收集算法：

### 如何进入GC

* 枚举根节点：Stop the world
* 安全点：
   * 抢先式中断
   * 主动式中断

### 垃圾收集器：具体实现

> 垃圾收集器中并发以及并行的概念：
>
> * 并行（Parallel）：指的是多线程并行进行垃圾收集，但用户线程仍然是暂停状态
> * 并发（Concurrent）：指的是垃圾收集与用户线程同时进行

* Serial：Client模式，单线程情况下是很好的选择，没有线程交互的开销
* ParNew：Serial的多线程版本，新生代采用复制算法，老年代采用标记-整理算法，同样是Stop the world
* Parallel Scavenge：新生代收集，可控制的吞吐量，吞吐量描述的是用户线程执行时间和垃圾收集时间的比
* Serial Old：
* Parallel Old：
* CMS(Concurrent Mark Sweep)：主要作用于老年代，大多应用在B/S系统的服务器上，标记清除算法，并发的低停顿的，默认启动的线程数量是（CPU num +3）/4
   * CMS有一个触发阈值，JDK1.5时默认的对老年代的内存回收的阈值是62%，而在1.6时提升到了92%，然而当老年代增速太快时而预留内存无法满足时，就会造成Concurrent mode failure.
   * 由于使用的是标记-清除算法，会有大量内存碎片，从而容易引发Full GC,
      * 可以使用开关参数：-XX:+UseCMSCompactAtFullCollection(默认是开启的)，在进行Full GC前先对空间进行整理
      * -XX:CMSFullGCsBeforeCompaction:用于设置多少次不压缩Full GC后，进行一次带压缩的，默认值是0，表示每次进行Full GC 时进行整理
* G1：同样立足于停顿时间，低停顿

GC 处理常用参数：

![image-20201018121557218](/Users/apple/Desktop/My-Study-Notes/JVM/image-20201018121557218.png)

![image-20201018121630337](/Users/apple/Desktop/My-Study-Notes/JVM/image-20201018121630337.png)



### 内存分配和回收策略：

要避免大对象，且避免短命大对象

## 虚拟机性能监控与故障处理工具：

常用的工具：![image-20201018155014063](/Users/apple/Desktop/My-Study-Notes/JVM/image-20201018155014063.png)

* 可视化的工具：JConsole,VisualVM

## 类文件结构

* 魔数与Class文件的版本：4个字节，唯一的作用时确定该文件是不是能被虚拟机接受
* 版本号：56，78字节决定版本号
* 常量池：
   * 字面量：文本字符串，声明，final的常量池
   * 符号引用：类和接口的全限定名，字段的名称和描述名，方法的名称和描述名
* 访问标志：用于识别一些类或者接口的层次的访问信息，例如时类还是接口，是否为public类型
* 类索引，父类索引和接口索引集合
* 成员变量表集合：
* 方法表集合：方法的属性，方法体不在这里
* 属性表集合：

## 高效并发：

线程的5种状态：

* Running 运行时
* New 创建新的线程
* Blocked：阻塞状态
* Timed Waiting：限期等待
* Terminated：线程结束

![image-20201019160349602](/Users/apple/Desktop/My-Study-Notes/JVM/image-20201019160349602.png)

> ThreadLocal 进行本地线程存储，使得每一个线程的Thread对象中都有一个ThreadLocalMap对象，HachCode为键，本地线程变量为值

### 锁的优化🔒

* 自旋锁和自适应自旋

   开启：--XX:UseSpinning

   设置自旋的次数：--XX:PreBlockSpin	

   自适应自旋是指自旋的次数或时间不固定，而是由前一次在同一锁上的自旋时间及锁的拥有者的状态来决定

* 锁消除：

锁消除是指虚拟机即时编译器上运行，对一些代码上要求同步，但是检测都不可能存在共享数据竞争的锁进行消除

* 锁粗化

例如StringBuilder中的append()方法，单方法时加锁的，如果多次连续执行，就会实现粗化锁，将锁加在连续语句的前后

* 轻量级锁

Mark word

重新建立轻量级锁的认识，轻量级的锁并不是用来代替重量级锁的，相反如果频繁存在锁竞争，除了互斥量的开销外，还额外有CAS的开销，所以比重量级锁更慢

* 偏向锁

一种锁优化，目的是消除数据在无竞争情况下的同步原语，进一步提高运行的性能。比轻量级更恨，直接在无竞争情况下消除整个同步块

开启: --XX:+UseBiasedLocking